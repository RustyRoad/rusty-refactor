{
  "name": "rusty-refactor",
  "displayName": "Rusty Refactor",
  "description": "Smart Rust code refactoring for RustyRoad - extract code to modules with intelligent type detection and file browsing",
  "version": "0.4.1",
  "publisher": "rusty-refactor",
  "repository": {
    "type": "git",
    "url": "https://github.com/RustyRoad/rusty-refactor"
  },
  "engines": {
    "vscode": "^1.105.0"
  },
  "categories": [
    "Programming Languages",
    "Formatters",
    "Other"
  ],
  "keywords": [
    "rust",
    "rustyroad",
    "refactoring",
    "module",
    "extract",
    "rust-analyzer",
    "rails"
  ],
  "activationEvents": [
    "onLanguage:rust",
    "workspaceContains:**/Cargo.toml"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "rustyRefactor.extractToModule",
        "title": "Rusty Refactor: Extract to Module"
      },
      {
        "command": "rustyRefactor.extractToModuleWithSearch",
        "title": "Rusty Refactor: Extract to Module (Browse Files)"
      },
      {
        "command": "rustyRefactor.extractToModuleCustomPath",
        "title": "Rusty Refactor: Extract to Module (Custom Path)"
      }
    ],
    "languageModelTools": [
      {
        "name": "rustyRefactor_extract_to_module",
        "displayName": "Extract Rust Code to Module",
        "modelDescription": "Extracts selected Rust code from a source file and creates a new module file with intelligent import handling, impl block preservation, and automatic parent module registration. This tool should be used when refactoring Rust code to improve modularity and organization. It handles complex scenarios including: extracting methods from impl blocks (preserves the impl wrapper), copying all necessary imports from the original file, detecting and importing types from parent modules, adjusting relative import paths (super::, self::) to absolute paths (crate::), and automatically registering the new module in the parent with 'pub mod' and 'pub use' statements. The tool works best with complete functions, structs, enums, traits, or impl blocks. It will NOT work with partial code snippets or incomplete syntax. File paths must be absolute paths. Line numbers are 1-based and inclusive.",
        "icon": "$(symbol-namespace)",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "extract_rust_module",
        "userDescription": "Extract Rust code to a new module with smart imports and module registration",
        "tags": [
          "rust",
          "refactor",
          "module",
          "extract",
          "code-organization"
        ],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sourceFilePath": {
              "type": "string",
              "description": "The absolute file path of the Rust source file containing the code to extract. Must be a .rs file."
            },
            "startLine": {
              "type": "number",
              "description": "The starting line number of the code to extract (1-based, inclusive). Should point to the beginning of a complete Rust item (function, struct, impl block, etc.)."
            },
            "endLine": {
              "type": "number",
              "description": "The ending line number of the code to extract (1-based, inclusive). Should point to the end of a complete Rust item."
            },
            "moduleName": {
              "type": "string",
              "description": "The name of the module to create. Must be in snake_case format (lowercase with underscores), following Rust naming conventions. Examples: 'email_repository', 'user_service', 'pricing_utils'."
            },
            "modulePath": {
              "type": "string",
              "description": "Optional: The relative path where the module file should be created (e.g., 'src/models/email_repository.rs' or 'src/services/user_service.rs'). If not provided, will use the default path from settings (typically 'src/{moduleName}.rs'). For RustyRoad projects, conventional paths include: controllers/, models/, services/, middleware/, helpers/, utils/."
            }
          },
          "required": ["sourceFilePath", "startLine", "endLine", "moduleName"]
        }
      },
      {
        "name": "rustyRefactor_analyze_rust_code",
        "displayName": "Analyze Rust Code",
        "modelDescription": "Analyzes a selection of Rust code and provides detailed information about its structure, dependencies, and components. This tool should be used when you need to understand what a piece of Rust code contains before refactoring or when gathering information for code review. It detects and reports: all functions with their visibility and generic parameters, all structs with field counts and visibility, all enums with variant counts, all traits, implementation blocks (impl) including trait implementations, whether the code is inside an impl block, all used types and traits, all imports (use statements), overall visibility level, and presence of generic parameters. The tool is useful for determining if code is suitable for extraction to a module and understanding its dependencies. File paths must be absolute paths. Line numbers are 1-based and inclusive.",
        "icon": "$(search)",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "analyze_rust",
        "userDescription": "Analyze Rust code structure, dependencies, and components",
        "tags": [
          "rust",
          "analyze",
          "inspection",
          "code-structure"
        ],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute file path of the Rust source file to analyze. Must be a .rs file."
            },
            "startLine": {
              "type": "number",
              "description": "The starting line number to analyze (1-based, inclusive)."
            },
            "endLine": {
              "type": "number",
              "description": "The ending line number to analyze (1-based, inclusive)."
            }
          },
          "required": ["filePath", "startLine", "endLine"]
        }
      }
    ],
    "menus": {
      "editor/context": [
        {
          "when": "editorHasSelection && editorLangId == rust",
          "command": "rustyRefactor.extractToModuleWithSearch",
          "group": "1_modification@1"
        },
        {
          "when": "editorHasSelection && editorLangId == rust",
          "command": "rustyRefactor.extractToModule",
          "group": "1_modification@2"
        },
        {
          "when": "editorHasSelection && editorLangId == rust",
          "command": "rustyRefactor.extractToModuleCustomPath",
          "group": "1_modification@3"
        }
      ]
    },
    "configuration": {
      "title": "Rusty Refactor",
      "properties": {
        "rustyRefactor.rustyRoadMode": {
          "type": "boolean",
          "default": true,
          "description": "Enable RustyRoad-specific conventions (suggests controllers, models, services, etc.)"
        },
        "rustyRefactor.defaultModulePath": {
          "type": "string",
          "default": "src",
          "description": "Default path for new modules"
        },
        "rustyRefactor.autoFormatAfterRefactor": {
          "type": "boolean",
          "default": true,
          "description": "Automatically format files after refactoring"
        },
        "rustyRefactor.addModuleDocComments": {
          "type": "boolean",
          "default": true,
          "description": "Add documentation comments to extracted modules"
        },
        "rustyRefactor.integrationWithRustAnalyzer": {
          "type": "boolean",
          "default": true,
          "description": "Integrate with rust-analyzer for better type detection and unused import cleanup"
        },
        "rustyRefactor.aiAutoDocumentation": {
          "type": "boolean",
          "default": false,
          "description": "Automatically generate AI-powered documentation for extracted modules using GitHub Copilot"
        },
        "rustyRefactor.aiAskEachTime": {
          "type": "boolean",
          "default": true,
          "description": "Ask before generating AI documentation each time (if aiAutoDocumentation is false)"
        },
        "rustyRefactor.searchDepth": {
          "type": "number",
          "default": 5,
          "description": "Maximum directory depth for file search"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run build:rust && npm run compile",
    "build:rust": "cargo build --release --manifest-path rust-backend/Cargo.toml",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "pretest": "npm run compile",
    "lint": "eslint src --ext ts",
    "test": "node ./out/test/runTest.js",
    "package": "vsce package",
    "publish": "vsce publish",
    "build": "npm run build:rust && npm run compile",
    "package-publish": "npm run build && npm run package"
  },
  "devDependencies": {
    "@types/node": "24.9.2",
    "@types/vscode": "1.105.0",
    "@vscode/vsce": "3.6.2",
    "@typescript-eslint/eslint-plugin": "8.46.2",
    "@typescript-eslint/parser": "8.46.2",
    "eslint": "9.39.0",
    "typescript": "^5.0.4"
  },
  "dependencies": {}
}

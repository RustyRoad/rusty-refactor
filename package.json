{
  "name": "rusty-refactor",
  "displayName": "Rusty Refactor",
  "description": "Smart Rust code refactoring for RustyRoad - extract code to modules with intelligent type detection and file browsing",
  "version": "0.5.00",
  "publisher": "rusty-refactor",
  "repository": {
    "type": "git",
    "url": "https://github.com/RustyRoad/rusty-refactor"
  },
  "engines": {
    "vscode": "^1.105.0"
  },
  "categories": [
    "Programming Languages",
    "Formatters",
    "Other"
  ],
  "keywords": [
    "rust",
    "rustyroad",
    "refactoring",
    "module",
    "extract",
    "rust-analyzer",
    "rails"
  ],
  "activationEvents": [
    "onLanguage:rust",
    "workspaceContains:**/Cargo.toml"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "rustyRefactor.extractToModule",
        "title": "Rusty Refactor: Extract to Module"
      },
      {
        "command": "rustyRefactor.extractToModuleWithSearch",
        "title": "Rusty Refactor: Extract to Module (Browse Files)"
      },
      {
        "command": "rustyRefactor.extractToModuleCustomPath",
        "title": "Rusty Refactor: Extract to Module (Custom Path)"
      },
      {
        "command": "rustyRefactor.selectAIModel",
        "title": "Rusty Refactor: Select AI Model for Documentation"
      }
    ],
    "languageModelTools": [
      {
        "name": "rustyRefactor_extract_to_module",
        "displayName": "Extract Rust Code to Module",
        "modelDescription": "Extracts selected Rust code from a source file and creates a new module file with:\n- Intelligent import handling\n- Impl block preservation\n- Automatic parent module registration\n- rust-analyzer validation\n\nThis tool enforces Rust conventions and ensures only clean, compiling code is delivered.\n\nCRITICAL REQUIREMENTS:\n1) modulePath must be RELATIVE to workspace root, starting with 'src/'.\n   - DO NOT include workspace root path.\n   - Example (CORRECT): 'src/controllers/ads/facebook/facebook_ads.rs'\n   - Example (WRONG): '/home/user/project/src/...'\n   - The 'src/' folder ALREADY EXISTS; do not try to create it.\n2) Module structure must follow 'one module per folder'.\n   - Each module file must be in its own folder with a mod.rs.\n   - Example: 'src/controllers/ads/facebook/' contains both 'mod.rs' AND 'facebook_ads.rs'.\n   - Flat structures like 'src/controllers/ads/facebook_ads.rs' are REJECTED with error.\n3) moduleName must be snake_case (lowercase_with_underscores).\n\nThe tool automatically:\n- Validates extracted code compiles with rust-analyzer (3 auto-fix attempts)\n- Creates missing folders and mod.rs files\n- Removes extracted code from source (no comments)\n- Normalizes paths using built-in Utils.extractWorkspaceRoot()\n- Applies all changes atomically using WorkspaceEdit API\n\nReturns structured JSON with success status, extracted items, and import statements.\nTool will ABORT if validation fails after auto-fix attempts."
        "icon": "$(symbol-namespace)",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "extract_rust_module",
        "userDescription": "Extract Rust code to a new module with validation and auto-fixing",
        "tags": [
          "rust",
          "refactor",
          "module",
          "extract",
          "code-organization"
        ],
        "inputSchema": {
          "type": "object",
          "properties": {
            "sourceFilePath": {
              "type": "string",
              "description": "The absolute file path of the Rust source file containing the code to extract. Must be a .rs file."
            },
            "startLine": {
              "type": "number",
              "description": "The starting line number of the code to extract (1-based, inclusive). Should point to the beginning of a complete Rust item (function, struct, impl block, etc.)."
            },
            "endLine": {
              "type": "number",
              "description": "The ending line number of the code to extract (1-based, inclusive). Should point to the end of a complete Rust item."
            },
            "moduleName": {
              "type": "string",
              "description": "The name of the module to create. REQUIRED FORMAT: snake_case (lowercase with underscores). Examples: 'facebook_ads', 'user_service', 'email_repository'. Will be validated and rejected if not snake_case."
            },
            "modulePath": {
              "type": "string",
              "description": "CRITICAL: Must be RELATIVE path starting with 'src/' - DO NOT include workspace root. The 'src/' directory already exists in the workspace. REQUIRED STRUCTURE: Module must be in its own folder with mod.rs. CORRECT EXAMPLES: 'src/controllers/ads/facebook/facebook_ads.rs' (creates folder 'facebook/' with mod.rs + facebook_ads.rs), 'src/models/user/user_repository.rs'. WRONG EXAMPLES: 'src/controllers/ads/facebook_ads.rs' (flat structure - REJECTED), '/home/user/project/src/...' (absolute path - will be normalized but avoid). Folders are auto-created. For RustyRoad projects use: src/controllers/, src/models/, src/services/, src/middleware/, src/helpers/, src/utils/. If omitted, defaults to 'src/{moduleName}.rs'."
            },
            "functionName": {
              "type": "string",
              "description": "Optional: Name of a specific function/struct/enum to extract using symbol matching (more reliable than line numbers). If provided, the tool will find the symbol by name and extract it, using line numbers only as fallback."
            }
          },
          "required": [
            "sourceFilePath",
            "startLine",
            "endLine",
            "moduleName"
          ]
        }
      },
      {
        "name": "rustyRefactor_analyze_rust_code",
        "displayName": "Analyze Rust Code",
        "modelDescription": "Analyzes a selection of Rust code and provides detailed information about its structure, dependencies, and components. This tool should be used when you need to understand what a piece of Rust code contains before refactoring or when gathering information for code review. It detects and reports: all functions with their visibility and generic parameters, all structs with field counts and visibility, all enums with variant counts, all traits, implementation blocks (impl) including trait implementations, whether the code is inside an impl block, all used types and traits, all imports (use statements), overall visibility level, and presence of generic parameters. The tool is useful for determining if code is suitable for extraction to a module and understanding its dependencies. File paths must be absolute paths. Line numbers are 1-based and inclusive.",
        "icon": "$(search)",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "analyze_rust",
        "userDescription": "Analyze Rust code structure, dependencies, and components",
        "tags": [
          "rust",
          "analyze",
          "inspection",
          "code-structure"
        ],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute file path of the Rust source file to analyze. Must be a .rs file."
            },
            "startLine": {
              "type": "number",
              "description": "The starting line number to analyze (1-based, inclusive)."
            },
            "endLine": {
              "type": "number",
              "description": "The ending line number to analyze (1-based, inclusive)."
            }
          },
          "required": [
            "filePath",
            "startLine",
            "endLine"
          ]
        }
      },
      {
        "name": "rustyRefactor_refactor_file",
        "displayName": "Refactor Rust File",
        "modelDescription": "High-level orchestration tool that automatically refactors an entire Rust file. This tool automatically: 1) Analyzes the file to discover extractable symbols, 2) Extracts each symbol to appropriate modules based on RustyRoad conventions, 3) Suggests missing imports using existing TypeScript utilities, 4) Returns a complete refactoring plan. The tool leverages the extract_rust_module and analyze_rust tools internally and uses built-in Utils class functions for path normalization and string manipulation. LLM doesn't need to do ANY work - just call this tool with the file path and optionally specify target directory or symbols to extract. The tool handles all the complexity of symbol matching, module creation, and import fixing automatically.",
        "icon": "$(file-code)",
        "canBeReferencedInPrompt": true,
        "toolReferenceName": "refactor_rust_file",
        "userDescription": "Automatically refactor an entire Rust file with analysis, extraction, and import fixing",
        "tags": [
          "rust",
          "refactor",
          "orchestration",
          "automation",
          "code-organization"
        ],
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The absolute path to the Rust file to refactor"
            },
            "targetDirectory": {
              "type": "string",
              "description": "Optional: Target directory for extracted modules (defaults to RustyRoad conventions). Examples: 'src/models', 'src/services', 'src/controllers'"
            },
            "symbolsToExtract": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional: Specific symbols to extract (if empty, extracts all public items)"
            },
            "autoFixImports": {
              "type": "boolean",
              "description": "Optional: Whether to auto-fix missing imports (default: true)"
            }
          },
          "required": [
            "filePath"
          ]
        }
      }
    ],
    "menus": {
      "editor/context": [
        {
          "when": "editorHasSelection && editorLangId == rust",
          "command": "rustyRefactor.extractToModuleWithSearch",
          "group": "1_modification@1"
        },
        {
          "when": "editorHasSelection && editorLangId == rust",
          "command": "rustyRefactor.extractToModule",
          "group": "1_modification@2"
        },
        {
          "when": "editorHasSelection && editorLangId == rust",
          "command": "rustyRefactor.extractToModuleCustomPath",
          "group": "1_modification@3"
        }
      ]
    },
    "configuration": {
      "title": "Rusty Refactor",
      "properties": {
        "rustyRefactor.rustyRoadMode": {
          "type": "boolean",
          "default": true,
          "description": "Enable RustyRoad-specific conventions (suggests controllers, models, services, etc.)"
        },
        "rustyRefactor.defaultModulePath": {
          "type": "string",
          "default": "src",
          "description": "Default path for new modules"
        },
        "rustyRefactor.autoFormatAfterRefactor": {
          "type": "boolean",
          "default": true,
          "description": "Automatically format files after refactoring"
        },
        "rustyRefactor.addModuleDocComments": {
          "type": "boolean",
          "default": true,
          "description": "Add documentation comments to extracted modules"
        },
        "rustyRefactor.integrationWithRustAnalyzer": {
          "type": "boolean",
          "default": true,
          "description": "Integrate with rust-analyzer for better type detection and unused import cleanup"
        },
        "rustyRefactor.aiAutoDocumentation": {
          "type": "boolean",
          "default": false,
          "description": "Automatically generate AI-powered documentation for extracted modules using GitHub Copilot"
        },
        "rustyRefactor.aiAskEachTime": {
          "type": "boolean",
          "default": true,
          "description": "Ask before generating AI documentation each time (if aiAutoDocumentation is false)"
        },
        "rustyRefactor.aiPreferredModel": {
          "type": "string",
          "default": "",
          "description": "Preferred AI model for documentation (format: vendor/family). Use 'Rusty Refactor: Select AI Model' command to choose."
        },
        "rustyRefactor.searchDepth": {
          "type": "number",
          "default": 5,
          "description": "Maximum directory depth for file search"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run build",
    "build:rust": "cargo build --release --manifest-path rust-backend/Cargo.toml",
    "build:ts": "rsbuild build",
    "build": "npm run build:rust && npm run build:ts",
    "watch": "rsbuild build --watch",
    "watch:ts": "rsbuild build --watch",
    "dev": "rsbuild dev",
    "pretest": "npm run build",
    "lint": "eslint src --ext ts",
    "test": "node ./out/test/runTest.js",
    "package": "vsce package",
    "publish": "vsce publish",
    "package-publish": "npm run package"
  },
  "devDependencies": {
    "@types/node": "24.9.2",
    "@types/vscode": "1.105.0",
    "@vscode/vsce": "3.6.2",
    "@typescript-eslint/eslint-plugin": "8.46.2",
    "@typescript-eslint/parser": "8.46.2",
    "@rsbuild/core": "1.6.0",
    "eslint": "9.39.0",
    "typescript": "^5.0.4"
  },
  "dependencies": {}
}

Summarized conversation historySummarized conversation historyI see file creation tools are disabled. Let me provide the comprehensive requirements document directly:

---

# Rusty Refactor: Ultimate Rust IDE Extension
## Technical Requirements & Architecture for World-Class Implementation

**Target**: The most powerful, accurate, and performant Rust IDE extension ever built.

**Team Capabilities**: Assembly, C, C++, Rust - full systems-level control.

---

## ðŸŽ¯ Core Philosophy

**Zero Compromise on Accuracy**: Use the actual Rust compiler internals, not heuristics.

**Performance First**: Multi-threaded, incremental, cached - treat this like a game engine.

**Deep Integration**: Hook directly into compiler internals via FFI when needed.

---

## ðŸ“‹ PHASE 1: Compiler Integration Layer (CRITICAL)

### 1.1 Direct rustc Integration via FFI

**Goal**: Bypass cargo check JSON parsing. Hook directly into rustc's HIR/MIR.

**Requirements**:
- Build custom rustc driver as shared library (.dll/.so/.dylib)
- Expose C ABI for TypeScript <-> Rust FFI via N-API bindings
- Direct memory-mapped access to HIR (High-level Intermediate Representation)
- Zero-copy data structures for type information

**Benefits**:
- 100% accuracy (using compiler's actual resolution)
- 50-100x faster than cargo check
- Access to ALL compiler information (lifetimes, variance, etc.)

---

### 1.2 Incremental Compilation Database

**Goal**: Cache HIR between refactorings. Only recompile changed files.

**Requirements**:
- Implement query-based system like rust-analyzer's salsa
- Persistent on-disk cache (memory-mapped files)
- Track file dependencies and invalidation
- Parallel analysis of independent modules

**Architecture**:
```
TypeScript Extension (N-API)
  â†“ (FFI)
Rust Compiler Driver (Shared Lib)
  - rustc internals
  - HIR/MIR access
  - Incremental query system
  â†“
On-Disk Cache (.rusty-cache/)
  - HIR snapshots (bincode)
  - Type index (mmap'd hashtable)
  - Dependency graph
```

**Performance Target**: < 50ms for cached analysis, < 500ms cold start.

---

### 1.3 Name Resolution Engine

**Goal**: Perfect import suggestions using compiler's actual name resolution.

**Requirements**:
- Hook into rustc's `resolve` pass
- Access DefId (Definition ID) for every item
- Query trait implementations via Chalk
- Resolve associated types and projections

---

## ðŸ“‹ PHASE 2: Advanced Refactoring Engine

### 2.1 Lifetime Analysis & Inference

**Goal**: Automatically infer and insert lifetime parameters when extracting code.

**Requirements**:
- Access to rustc's borrow checker
- Lifetime region inference
- Variance analysis
- Outlives constraints

**Use Case**: Extract a function that borrows data. Extension automatically determines:
- Which lifetime parameters needed
- Lifetime bounds (e.g., `'a: 'b`)
- Whether to use `&'a T` or `&'static T`

---

### 2.2 Trait Bound Resolution

**Goal**: Preserve and infer trait bounds when refactoring generic code.

**Requirements**:
- Query trait solver (Chalk)
- Detect required trait bounds from usage
- Minimize trait bounds (remove redundant)
- Handle higher-ranked trait bounds (HRTB)

---

### 2.3 Ownership & Borrow Checker Integration

**Goal**: Validate refactorings don't break borrow checker. Suggest fixes.

**Requirements**:
- Run borrow checker on refactored code
- Detect move/borrow violations
- Suggest Clone/Copy where appropriate
- Handle Pin/Unpin for self-referential types

---

### 2.4 Macro Expansion & Handling

**Goal**: Refactor code inside macro expansions. Handle procedural macros.

**Requirements**:
- Access to macro expansion HIR
- Map expanded code back to source
- Detect code generated by macros (don't refactor)
- Handle derive macros specially

**Challenges**:
- Macro-generated code might not have source locations
- Hygiene rules affect name resolution
- Procedural macros are black boxes

---

## ðŸ“‹ PHASE 3: Performance Optimization

### 3.1 Multi-threaded Analysis

**Goal**: Analyze multiple files in parallel. Use all CPU cores.

**Requirements**:
- Thread pool for parallel analysis (rayon)
- Lock-free data structures where possible
- Work-stealing queue for load balancing
- SIMD for text processing (pattern matching)

**Performance Target**: 
- Analyze 10,000 file codebase in < 5 seconds
- Incremental update in < 100ms

---

### 3.2 Memory-Mapped Cache

**Goal**: Persist analysis results on disk. Load instantly on extension restart.

**Requirements**:
- Binary serialization (bincode/postcard)
- Memory-mapped files for zero-copy loading
- Versioning (invalidate cache on rustc version change)
- Compression (zstd) for disk space

---

### 3.3 SIMD Text Processing

**Goal**: Use SIMD instructions for fast pattern matching and text manipulation.

**Requirements**:
- AVX2/AVX-512 for x86, NEON for ARM
- Vectorized string search
- Parallel parsing of multiple tokens
- SIMD-accelerated UTF-8 validation

---

## ðŸ“‹ PHASE 4: Advanced Features

### 4.1 Whole-Program Optimization Hints

**Goal**: Analyze entire codebase for optimization opportunities.

**Requirements**:
- Detect cold code paths (for #[cold])
- Find hot loops (for #[inline])
- Identify allocation-heavy code
- Suggest const fn where possible

---

### 4.2 Unsafe Code Analyzer

**Goal**: Deep analysis of unsafe code. Verify safety invariants.

**Requirements**:
- Track unsafe operations (raw pointers, transmute, etc.)
- Verify aliasing rules (Stacked Borrows/Tree Borrows)
- Detect undefined behavior
- Integration with Miri for runtime checks

---

### 4.3 Concurrency Analyzer

**Goal**: Detect data races, deadlocks, and concurrency bugs.

**Requirements**:
- Track Send/Sync bounds
- Detect Arc<Mutex<T>> anti-patterns
- Find potential deadlocks (lock ordering)
- Suggest async where appropriate

---

## ðŸ“‹ PHASE 5: AI Integration (Beyond GPT)

### 5.1 Local ML Model for Code Understanding

**Goal**: Train custom model on Rust codebases for pattern recognition.

**Requirements**:
- Lightweight transformer model (< 1GB)
- Fine-tuned on Rust code
- Run inference locally (no API calls)
- ONNX runtime or libtorch C++ integration

**Use Cases**:
- Predict variable names
- Suggest function signatures
- Detect anti-patterns
- Generate idiomatic code

---

### 5.2 Pattern Mining from Crates.io

**Goal**: Mine patterns from top 10,000 crates. Learn best practices.

**Requirements**:
- Download and analyze crates.io corpus
- Extract common patterns (builder, newtype, etc.)
- Build pattern database
- Suggest patterns to users

---

## ðŸ“‹ PHASE 6: Developer Experience

### 6.1 Real-time Preview with Diff

**Goal**: Show refactoring result before applying. Interactive diff.

**Requirements**:
- Apply refactoring to in-memory AST
- Generate diff using diff-match-patch
- Syntax-highlighted preview
- Undo/redo stack

---

### 6.2 Code Actions & Quick Fixes

**Goal**: Instant fixes for common issues. One-click refactorings.

**Examples**:
- âš¡ Add missing import (< 10ms)
- âš¡ Implement missing trait methods
- âš¡ Add derive(Debug, Clone)
- âš¡ Convert to async
- âš¡ Extract to const
- âš¡ Inline variable
- âš¡ Rename (project-wide)

---

### 6.3 Inline Type Hints

**Goal**: Show inferred types inline. Like IntelliJ IDEA.

**Requirements**:
- Query type inference results
- Render hints without cluttering
- Show on hover with full details
- Configurable (disable for obvious types)

---

## ðŸ“‹ PHASE 7: Ecosystem & Tooling

### 7.1 Clippy Integration

**Goal**: Run Clippy lints as you type. Apply fixes inline.

**Requirements**:
- Clippy as library (not subprocess)
- Register custom lints
- Batch fix all issues
- Configurable lint levels

---

### 7.2 Cargo Feature Manager

**Goal**: Visual feature management. See impact of feature flags.

**Requirements**:
- Parse Cargo.toml features
- Show dependency tree with features
- Detect unused features
- Suggest feature combinations for minimal build

---

### 7.3 Benchmark Integration

**Goal**: Run criterion benchmarks inline. Show performance trends.

**Requirements**:
- Parse criterion output
- Graph performance over time
- Detect regressions
- Compare before/after refactoring

---

## ðŸŽ¯ Success Metrics

### Performance
- **Import suggestions**: < 50ms (currently ~2-5s)
- **Refactoring preview**: < 100ms
- **Full workspace analysis**: < 5s for 10k files
- **Memory usage**: < 500MB for large project

### Accuracy
- **Import resolution**: 99.9% (compiler-perfect)
- **Lifetime inference**: 95% correct
- **Trait bounds**: 90% minimal/correct
- **False positives**: < 1%

### Usability
- **Zero configuration**: Works out of the box
- **Graceful degradation**: Features degrade if unavailable
- **Error messages**: Actionable with fixes
- **Responsiveness**: Never block UI

---

## ðŸ› ï¸ Implementation Roadmap

### Sprint 1 (Weeks 1-2): Foundation
- Custom rustc driver with FFI
- N-API bindings TypeScript <-> Rust
- Basic HIR access
- Import resolution engine

### Sprint 2 (Weeks 3-4): Core Features
- Lifetime analyzer
- Trait bound resolver
- Borrow checker integration
- Incremental compilation cache

### Sprint 3 (Weeks 5-6): Performance
- Multi-threading
- Memory-mapped cache
- SIMD text processing
- Benchmark suite

### Sprint 4 (Weeks 7-8): Advanced
- Unsafe analyzer
- Concurrency checker
- Optimization hints
- Pattern database

### Sprint 5 (Weeks 9-10): Polish
- UI/UX refinement
- Documentation
- Testing (fuzzing, property tests)
- Release preparation

---

## ðŸ”§ Technical Stack

### Core
- **Rust**: rustc internals, N-API native module
- **C/C++**: Performance-critical paths, SIMD
- **Assembly**: Hot paths if needed
- **TypeScript**: VS Code extension API

### Libraries
- `rustc_driver`, `rustc_interface`, `rustc_middle`
- `napi-rs` (Rust N-API bindings)
- `rayon` (parallel processing)
- `memmap2` (memory-mapped files)
- `dashmap` (concurrent hashmap)
- `bincode`/`postcard` (serialization)
- `zstd` (compression)

### Tools
- `cargo-fuzz` (fuzzing)
- `criterion` (benchmarking)
- `valgrind`/`heaptrack` (profiling)
- `perf` (Linux profiling)

---

## ðŸš€ Beyond MVP

### Future Enhancements
- WebAssembly support (run in browser)
- LSP server (standalone IDE support)
- Plugin system (custom refactorings)
- Cloud sync (settings, patterns)
- Team collaboration features
- IDE-agnostic core library

### Research Areas
- Formal verification integration
- Symbolic execution for bug finding
- ML-powered code generation
- Natural language refactoring commands

---

**This is the blueprint for the world's best Rust IDE extension.**

**No compromises. Full compiler integration. Maximum performance.**

**When can we start building? ðŸš€**